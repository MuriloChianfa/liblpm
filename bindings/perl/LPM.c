/*
 * This file was generated automatically by ExtUtils::ParseXS version 3.51 from the
 * contents of LPM.xs. Do not edit this file, edit LPM.xs instead.
 *
 *    ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "LPM.xs"
/*
 * LPM.xs - XS bindings for liblpm
 *
 * High-performance Perl bindings for the liblpm C library.
 * Provides IPv4 and IPv6 longest prefix match operations.
 *
 * Copyright (c) Murilo Chianfa
 * Licensed under the Boost Software License 1.0
 */

#define PERL_NO_GET_CONTEXT
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

#include <string.h>
#include <stdlib.h>
#include <arpa/inet.h>

/* Include liblpm header - path set in Makefile.PL */
#include <lpm/lpm.h>

/* Type for our blessed object */
typedef struct {
    lpm_trie_t *trie;
    int is_ipv6;
    int destroyed;
} NetLPM;

/* Helper: Parse IPv4 address string to network byte order uint32_t */
static int
parse_ipv4_addr(const char *str, uint32_t *addr)
{
    struct in_addr in;
    if (inet_pton(AF_INET, str, &in) != 1) {
        return 0;
    }
    *addr = ntohl(in.s_addr);
    return 1;
}

/* Helper: Parse IPv4 address string to byte array */
static int
parse_ipv4_addr_bytes(const char *str, uint8_t *bytes)
{
    struct in_addr in;
    if (inet_pton(AF_INET, str, &in) != 1) {
        return 0;
    }
    memcpy(bytes, &in.s_addr, 4);
    return 1;
}

/* Helper: Parse IPv6 address string to byte array */
static int
parse_ipv6_addr(const char *str, uint8_t *bytes)
{
    struct in6_addr in6;
    if (inet_pton(AF_INET6, str, &in6) != 1) {
        return 0;
    }
    memcpy(bytes, &in6.s6_addr, 16);
    return 1;
}

/* Helper: Parse CIDR prefix notation (e.g., "192.168.0.0/16") */
static int
parse_prefix(const char *str, uint8_t *addr_bytes, uint8_t *prefix_len, int is_ipv6)
{
    char addr_buf[64];
    const char *slash;
    size_t addr_len;
    long len;
    char *endptr;
    int max_len = is_ipv6 ? 128 : 32;
    
    /* Find the '/' separator */
    slash = strchr(str, '/');
    if (!slash) {
        return 0;
    }
    
    /* Extract address part */
    addr_len = slash - str;
    if (addr_len >= sizeof(addr_buf)) {
        return 0;
    }
    memcpy(addr_buf, str, addr_len);
    addr_buf[addr_len] = '\0';
    
    /* Check for empty prefix length */
    if (*(slash + 1) == '\0') {
        return 0;
    }
    
    /* Parse the prefix length */
    len = strtol(slash + 1, &endptr, 10);
    if (*endptr != '\0' || len < 0 || len > max_len) {
        return 0;
    }
    *prefix_len = (uint8_t)len;
    
    /* Parse the address */
    if (is_ipv6) {
        if (!parse_ipv6_addr(addr_buf, addr_bytes)) {
            return 0;
        }
    } else {
        if (!parse_ipv4_addr_bytes(addr_buf, addr_bytes)) {
            return 0;
        }
    }
    
    return 1;
}

#line 127 "LPM.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef dVAR
#  define dVAR		dNOOP
#endif


/* This stuff is not part of the API! You have been warned. */
#ifndef PERL_VERSION_DECIMAL
#  define PERL_VERSION_DECIMAL(r,v,s) (r*1000000 + v*1000 + s)
#endif
#ifndef PERL_DECIMAL_VERSION
#  define PERL_DECIMAL_VERSION \
	  PERL_VERSION_DECIMAL(PERL_REVISION,PERL_VERSION,PERL_SUBVERSION)
#endif
#ifndef PERL_VERSION_GE
#  define PERL_VERSION_GE(r,v,s) \
	  (PERL_DECIMAL_VERSION >= PERL_VERSION_DECIMAL(r,v,s))
#endif
#ifndef PERL_VERSION_LE
#  define PERL_VERSION_LE(r,v,s) \
	  (PERL_DECIMAL_VERSION <= PERL_VERSION_DECIMAL(r,v,s))
#endif

/* XS_INTERNAL is the explicit static-linkage variant of the default
 * XS macro.
 *
 * XS_EXTERNAL is the same as XS_INTERNAL except it does not include
 * "STATIC", ie. it exports XSUB symbols. You probably don't want that
 * for anything but the BOOT XSUB.
 *
 * See XSUB.h in core!
 */


/* TODO: This might be compatible further back than 5.10.0. */
#if PERL_VERSION_GE(5, 10, 0) && PERL_VERSION_LE(5, 15, 1)
#  undef XS_EXTERNAL
#  undef XS_INTERNAL
#  if defined(__CYGWIN__) && defined(USE_DYNAMIC_LOADING)
#    define XS_EXTERNAL(name) __declspec(dllexport) XSPROTO(name)
#    define XS_INTERNAL(name) STATIC XSPROTO(name)
#  endif
#  if defined(__SYMBIAN32__)
#    define XS_EXTERNAL(name) EXPORT_C XSPROTO(name)
#    define XS_INTERNAL(name) EXPORT_C STATIC XSPROTO(name)
#  endif
#  ifndef XS_EXTERNAL
#    if defined(HASATTRIBUTE_UNUSED) && !defined(__cplusplus)
#      define XS_EXTERNAL(name) void name(pTHX_ CV* cv __attribute__unused__)
#      define XS_INTERNAL(name) STATIC void name(pTHX_ CV* cv __attribute__unused__)
#    else
#      ifdef __cplusplus
#        define XS_EXTERNAL(name) extern "C" XSPROTO(name)
#        define XS_INTERNAL(name) static XSPROTO(name)
#      else
#        define XS_EXTERNAL(name) XSPROTO(name)
#        define XS_INTERNAL(name) STATIC XSPROTO(name)
#      endif
#    endif
#  endif
#endif

/* perl >= 5.10.0 && perl <= 5.15.1 */


/* The XS_EXTERNAL macro is used for functions that must not be static
 * like the boot XSUB of a module. If perl didn't have an XS_EXTERNAL
 * macro defined, the best we can do is assume XS is the same.
 * Dito for XS_INTERNAL.
 */
#ifndef XS_EXTERNAL
#  define XS_EXTERNAL(name) XS(name)
#endif
#ifndef XS_INTERNAL
#  define XS_INTERNAL(name) XS(name)
#endif

/* Now, finally, after all this mess, we want an ExtUtils::ParseXS
 * internal macro that we're free to redefine for varying linkage due
 * to the EXPORT_XSUB_SYMBOLS XS keyword. This is internal, use
 * XS_EXTERNAL(name) or XS_INTERNAL(name) in your code if you need to!
 */

#undef XS_EUPXS
#if defined(PERL_EUPXS_ALWAYS_EXPORT)
#  define XS_EUPXS(name) XS_EXTERNAL(name)
#else
   /* default to internal */
#  define XS_EUPXS(name) XS_INTERNAL(name)
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
	    Perl_croak_nocontext("Usage: %s::%s(%s)", hvname, gvname, params);
        else
	    Perl_croak_nocontext("Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
	Perl_croak_nocontext("Usage: CODE(0x%" UVxf ")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#define croak_xs_usage        S_croak_xs_usage

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#if PERL_VERSION_LE(5, 21, 5)
#  define newXS_deffile(a,b) Perl_newXS(aTHX_ a,b,file)
#else
#  define newXS_deffile(a,b) Perl_newXS_deffile(aTHX_ a,b)
#endif

#line 271 "LPM.c"

XS_EUPXS(XS_Net__LPM__xs_new_ipv4); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Net__LPM__xs_new_ipv4)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
#line 125 "LPM.xs"
        NetLPM *self;
#line 282 "LPM.c"
	SV *	RETVAL;
#line 127 "LPM.xs"
        Newxz(self, 1, NetLPM);
        self->trie = lpm_create_ipv4();
        if (!self->trie) {
            Safefree(self);
            croak("Failed to create IPv4 LPM table");
        }
        self->is_ipv6 = 0;
        self->destroyed = 0;
        RETVAL = newSViv(PTR2IV(self));
#line 294 "LPM.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Net__LPM__xs_new_ipv6); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Net__LPM__xs_new_ipv6)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
#line 143 "LPM.xs"
        NetLPM *self;
#line 311 "LPM.c"
	SV *	RETVAL;
#line 145 "LPM.xs"
        Newxz(self, 1, NetLPM);
        self->trie = lpm_create_ipv6();
        if (!self->trie) {
            Safefree(self);
            croak("Failed to create IPv6 LPM table");
        }
        self->is_ipv6 = 1;
        self->destroyed = 0;
        RETVAL = newSViv(PTR2IV(self));
#line 323 "LPM.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Net__LPM__xs_destroy); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Net__LPM__xs_destroy)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self_iv");
    {
	IV	self_iv = (IV)SvIV(ST(0))
;
#line 162 "LPM.xs"
        NetLPM *self;
#line 342 "LPM.c"
#line 164 "LPM.xs"
        self = INT2PTR(NetLPM*, self_iv);
        if (self && !self->destroyed) {
            if (self->trie) {
                lpm_destroy(self->trie);
                self->trie = NULL;
            }
            self->destroyed = 1;
        }
#line 352 "LPM.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Net__LPM__xs_free); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Net__LPM__xs_free)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self_iv");
    {
	IV	self_iv = (IV)SvIV(ST(0))
;
#line 178 "LPM.xs"
        NetLPM *self;
#line 369 "LPM.c"
#line 180 "LPM.xs"
        self = INT2PTR(NetLPM*, self_iv);
        if (self) {
            if (!self->destroyed && self->trie) {
                lpm_destroy(self->trie);
            }
            Safefree(self);
        }
#line 378 "LPM.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Net__LPM__xs_is_ipv6); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Net__LPM__xs_is_ipv6)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self_iv");
    {
	IV	self_iv = (IV)SvIV(ST(0))
;
#line 193 "LPM.xs"
        NetLPM *self;
#line 395 "LPM.c"
	int	RETVAL;
	dXSTARG;
#line 195 "LPM.xs"
        self = INT2PTR(NetLPM*, self_iv);
        RETVAL = self ? self->is_ipv6 : 0;
#line 401 "LPM.c"
	XSprePUSH;
	PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Net__LPM__xs_is_destroyed); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Net__LPM__xs_is_destroyed)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self_iv");
    {
	IV	self_iv = (IV)SvIV(ST(0))
;
#line 205 "LPM.xs"
        NetLPM *self;
#line 420 "LPM.c"
	int	RETVAL;
	dXSTARG;
#line 207 "LPM.xs"
        self = INT2PTR(NetLPM*, self_iv);
        RETVAL = self ? self->destroyed : 1;
#line 426 "LPM.c"
	XSprePUSH;
	PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Net__LPM__xs_insert); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Net__LPM__xs_insert)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "self_iv, prefix_str, next_hop");
    {
	IV	self_iv = (IV)SvIV(ST(0))
;
	const char *	prefix_str = (const char *)SvPV_nolen(ST(1))
;
	unsigned int	next_hop = (unsigned int)SvUV(ST(2))
;
#line 219 "LPM.xs"
        NetLPM *self;
        uint8_t addr_bytes[16];
        uint8_t prefix_len;
        int result;
#line 452 "LPM.c"
	int	RETVAL;
	dXSTARG;
#line 224 "LPM.xs"
        self = INT2PTR(NetLPM*, self_iv);
        if (!self || self->destroyed || !self->trie) {
            croak("Cannot insert into destroyed or invalid table");
        }

        if (!parse_prefix(prefix_str, addr_bytes, &prefix_len, self->is_ipv6)) {
            croak("Invalid prefix format: %s", prefix_str);
        }

        result = lpm_add(self->trie, addr_bytes, prefix_len, (uint32_t)next_hop);
        if (result != 0) {
            croak("Failed to insert prefix: %s", prefix_str);
        }

        RETVAL = 1;
#line 471 "LPM.c"
	XSprePUSH;
	PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Net__LPM__xs_delete); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Net__LPM__xs_delete)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self_iv, prefix_str");
    {
	IV	self_iv = (IV)SvIV(ST(0))
;
	const char *	prefix_str = (const char *)SvPV_nolen(ST(1))
;
#line 248 "LPM.xs"
        NetLPM *self;
        uint8_t addr_bytes[16];
        uint8_t prefix_len;
        int result;
#line 495 "LPM.c"
	int	RETVAL;
	dXSTARG;
#line 253 "LPM.xs"
        self = INT2PTR(NetLPM*, self_iv);
        if (!self || self->destroyed || !self->trie) {
            croak("Cannot delete from destroyed or invalid table");
        }

        if (!parse_prefix(prefix_str, addr_bytes, &prefix_len, self->is_ipv6)) {
            croak("Invalid prefix format: %s", prefix_str);
        }

        result = lpm_delete(self->trie, addr_bytes, prefix_len);
        if (result != 0) {
            /* Prefix not found is not an error - just return 0 */
            RETVAL = 0;
        } else {
            RETVAL = 1;
        }
#line 515 "LPM.c"
	XSprePUSH;
	PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Net__LPM__xs_lookup); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Net__LPM__xs_lookup)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self_iv, addr_str");
    {
	IV	self_iv = (IV)SvIV(ST(0))
;
	const char *	addr_str = (const char *)SvPV_nolen(ST(1))
;
#line 278 "LPM.xs"
        NetLPM *self;
        uint32_t next_hop;
        uint32_t ipv4_addr;
        uint8_t ipv6_addr[16];
#line 539 "LPM.c"
	SV *	RETVAL;
#line 283 "LPM.xs"
        self = INT2PTR(NetLPM*, self_iv);
        if (!self || self->destroyed || !self->trie) {
            croak("Cannot lookup in destroyed or invalid table");
        }

        if (self->is_ipv6) {
            if (!parse_ipv6_addr(addr_str, ipv6_addr)) {
                croak("Invalid IPv6 address: %s", addr_str);
            }
            next_hop = lpm_lookup_ipv6(self->trie, ipv6_addr);
        } else {
            if (!parse_ipv4_addr(addr_str, &ipv4_addr)) {
                croak("Invalid IPv4 address: %s", addr_str);
            }
            next_hop = lpm_lookup_ipv4(self->trie, ipv4_addr);
        }

        if (next_hop == LPM_INVALID_NEXT_HOP) {
            RETVAL = &PL_sv_undef;
        } else {
            RETVAL = newSVuv(next_hop);
        }
#line 564 "LPM.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Net__LPM__xs_lookup_batch_ipv4); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Net__LPM__xs_lookup_batch_ipv4)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self_iv, addrs_av");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	IV	self_iv = (IV)SvIV(ST(0))
;
	SV *	addrs_av = ST(1)
;
#line 314 "LPM.xs"
        NetLPM *self;
        AV *av;
        SSize_t count;
        SSize_t i;
        uint32_t *addrs = NULL;
        uint32_t *results = NULL;
        SV **elem;
        const char *addr_str;
#line 594 "LPM.c"
#line 323 "LPM.xs"
        self = INT2PTR(NetLPM*, self_iv);
        if (!self || self->destroyed || !self->trie) {
            croak("Cannot lookup in destroyed or invalid table");
        }

        if (self->is_ipv6) {
            croak("Use lookup_batch for IPv6, not lookup_batch_ipv4");
        }

        if (!SvROK(addrs_av) || SvTYPE(SvRV(addrs_av)) != SVt_PVAV) {
            croak("lookup_batch_ipv4 requires an array reference");
        }
        av = (AV*)SvRV(addrs_av);

        count = av_len(av) + 1;
        if (count <= 0) {
            XSRETURN_EMPTY;
        }

        /* Allocate arrays */
        Newx(addrs, count, uint32_t);
        Newx(results, count, uint32_t);

        /* Parse all addresses */
        for (i = 0; i < count; i++) {
            elem = av_fetch(av, i, 0);
            if (!elem || !SvOK(*elem)) {
                Safefree(addrs);
                Safefree(results);
                croak("Invalid address at index %ld", (long)i);
            }
            addr_str = SvPV_nolen(*elem);
            if (!parse_ipv4_addr(addr_str, &addrs[i])) {
                Safefree(addrs);
                Safefree(results);
                croak("Invalid IPv4 address at index %ld: %s", (long)i, addr_str);
            }
        }

        /* Perform batch lookup */
        lpm_lookup_batch_ipv4(self->trie, addrs, results, (size_t)count);

        /* Push results onto the stack */
        EXTEND(SP, count);
        for (i = 0; i < count; i++) {
            if (results[i] == LPM_INVALID_NEXT_HOP) {
                PUSHs(&PL_sv_undef);
            } else {
                PUSHs(sv_2mortal(newSVuv(results[i])));
            }
        }

        Safefree(addrs);
        Safefree(results);
#line 650 "LPM.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_Net__LPM__xs_lookup_batch_ipv6); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Net__LPM__xs_lookup_batch_ipv6)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self_iv, addrs_av");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	IV	self_iv = (IV)SvIV(ST(0))
;
	SV *	addrs_av = ST(1)
;
#line 384 "LPM.xs"
        NetLPM *self;
        AV *av;
        SSize_t count;
        SSize_t i;
        uint8_t *addrs = NULL;  /* Flat array: count * 16 bytes */
        uint32_t *results = NULL;
        SV **elem;
        const char *addr_str;
#line 679 "LPM.c"
#line 393 "LPM.xs"
        self = INT2PTR(NetLPM*, self_iv);
        if (!self || self->destroyed || !self->trie) {
            croak("Cannot lookup in destroyed or invalid table");
        }

        if (!self->is_ipv6) {
            croak("Use lookup_batch for IPv4, not lookup_batch_ipv6");
        }

        if (!SvROK(addrs_av) || SvTYPE(SvRV(addrs_av)) != SVt_PVAV) {
            croak("lookup_batch_ipv6 requires an array reference");
        }
        av = (AV*)SvRV(addrs_av);

        count = av_len(av) + 1;
        if (count <= 0) {
            XSRETURN_EMPTY;
        }

        /* Allocate arrays - use flat array for IPv6 addresses */
        Newx(addrs, count * 16, uint8_t);
        Newx(results, count, uint32_t);

        /* Parse all addresses */
        for (i = 0; i < count; i++) {
            elem = av_fetch(av, i, 0);
            if (!elem || !SvOK(*elem)) {
                Safefree(addrs);
                Safefree(results);
                croak("Invalid address at index %ld", (long)i);
            }
            addr_str = SvPV_nolen(*elem);
            if (!parse_ipv6_addr(addr_str, &addrs[i * 16])) {
                Safefree(addrs);
                Safefree(results);
                croak("Invalid IPv6 address at index %ld: %s", (long)i, addr_str);
            }
        }

        /* Perform batch lookup - cast to proper type */
        lpm_lookup_batch_ipv6(self->trie, (const uint8_t (*)[16])addrs, results, (size_t)count);

        /* Push results onto the stack */
        EXTEND(SP, count);
        for (i = 0; i < count; i++) {
            if (results[i] == LPM_INVALID_NEXT_HOP) {
                PUSHs(&PL_sv_undef);
            } else {
                PUSHs(sv_2mortal(newSVuv(results[i])));
            }
        }

        Safefree(addrs);
        Safefree(results);
#line 735 "LPM.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_Net__LPM__xs_get_version); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Net__LPM__xs_get_version)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	const char *	RETVAL;
	dXSTARG;
#line 452 "LPM.xs"
        RETVAL = lpm_get_version();
#line 753 "LPM.c"
	sv_setpv(TARG, RETVAL);
	XSprePUSH;
	PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Net__LPM__xs_invalid_next_hop); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Net__LPM__xs_invalid_next_hop)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	unsigned int	RETVAL;
	dXSTARG;
#line 460 "LPM.xs"
        RETVAL = LPM_INVALID_NEXT_HOP;
#line 773 "LPM.c"
	XSprePUSH;
	PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Net__LPM__xs_print_stats); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Net__LPM__xs_print_stats)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self_iv");
    {
	IV	self_iv = (IV)SvIV(ST(0))
;
#line 469 "LPM.xs"
        NetLPM *self;
#line 792 "LPM.c"
#line 471 "LPM.xs"
        self = INT2PTR(NetLPM*, self_iv);
        if (self && !self->destroyed && self->trie) {
            lpm_print_stats(self->trie);
        }
#line 798 "LPM.c"
    }
    XSRETURN_EMPTY;
}

#ifdef __cplusplus
extern "C" {
#endif
XS_EXTERNAL(boot_Net__LPM); /* prototype to pass -Wmissing-prototypes */
XS_EXTERNAL(boot_Net__LPM)
{
#if PERL_VERSION_LE(5, 21, 5)
    dVAR; dXSARGS;
#else
    dVAR; dXSBOOTARGSXSAPIVERCHK;
#endif
#if PERL_VERSION_LE(5, 8, 999) /* PERL_VERSION_LT is 5.33+ */
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(file);

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
#if PERL_VERSION_LE(5, 21, 5)
    XS_VERSION_BOOTCHECK;
#  ifdef XS_APIVERSION_BOOTCHECK
    XS_APIVERSION_BOOTCHECK;
#  endif
#endif

        newXS_deffile("Net::LPM::_xs_new_ipv4", XS_Net__LPM__xs_new_ipv4);
        newXS_deffile("Net::LPM::_xs_new_ipv6", XS_Net__LPM__xs_new_ipv6);
        newXS_deffile("Net::LPM::_xs_destroy", XS_Net__LPM__xs_destroy);
        newXS_deffile("Net::LPM::_xs_free", XS_Net__LPM__xs_free);
        newXS_deffile("Net::LPM::_xs_is_ipv6", XS_Net__LPM__xs_is_ipv6);
        newXS_deffile("Net::LPM::_xs_is_destroyed", XS_Net__LPM__xs_is_destroyed);
        newXS_deffile("Net::LPM::_xs_insert", XS_Net__LPM__xs_insert);
        newXS_deffile("Net::LPM::_xs_delete", XS_Net__LPM__xs_delete);
        newXS_deffile("Net::LPM::_xs_lookup", XS_Net__LPM__xs_lookup);
        newXS_deffile("Net::LPM::_xs_lookup_batch_ipv4", XS_Net__LPM__xs_lookup_batch_ipv4);
        newXS_deffile("Net::LPM::_xs_lookup_batch_ipv6", XS_Net__LPM__xs_lookup_batch_ipv6);
        newXS_deffile("Net::LPM::_xs_get_version", XS_Net__LPM__xs_get_version);
        newXS_deffile("Net::LPM::_xs_invalid_next_hop", XS_Net__LPM__xs_invalid_next_hop);
        newXS_deffile("Net::LPM::_xs_print_stats", XS_Net__LPM__xs_print_stats);
#if PERL_VERSION_LE(5, 21, 5)
#  if PERL_VERSION_GE(5, 9, 0)
    if (PL_unitcheckav)
        call_list(PL_scopestack_ix, PL_unitcheckav);
#  endif
    XSRETURN_YES;
#else
    Perl_xs_boot_epilog(aTHX_ ax);
#endif
}

#ifdef __cplusplus
}
#endif
