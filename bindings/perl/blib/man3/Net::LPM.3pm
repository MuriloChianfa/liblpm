.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.0102 (Pod::Simple 3.45)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Net::LPM 3pm"
.TH Net::LPM 3pm 2026-01-29 "perl v5.40.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
Net::LPM \- High\-performance Perl bindings for liblpm Longest Prefix Match library
.SH VERSION
.IX Header "VERSION"
Version 2.0.0
.SH SYNOPSIS
.IX Header "SYNOPSIS"
.Vb 1
\&    use Net::LPM;
\&    
\&    # Create an IPv4 routing table
\&    my $table = Net::LPM\->new_ipv4();
\&    
\&    # Insert routes (CIDR notation)
\&    $table\->insert("192.168.0.0/16", 100);
\&    $table\->insert("10.0.0.0/8", 200);
\&    $table\->insert("0.0.0.0/0", 999);  # Default route
\&    
\&    # Lookup an address
\&    my $next_hop = $table\->lookup("192.168.1.1");
\&    if (defined $next_hop) {
\&        print "Next hop: $next_hop\en";  # Prints: Next hop: 100
\&    }
\&    
\&    # Batch lookup (more efficient for multiple addresses)
\&    my @addresses = qw(192.168.1.1 10.1.1.1 172.16.0.1);
\&    my @next_hops = $table\->lookup_batch(\e@addresses);
\&    
\&    # Delete a route
\&    $table\->delete("10.0.0.0/8");
\&    
\&    # Table is automatically destroyed when $table goes out of scope
.Ve
.SH DESCRIPTION
.IX Header "DESCRIPTION"
Net::LPM provides high-performance Perl bindings to the liblpm C library
for Longest Prefix Match (LPM) routing table operations.
.PP
LPM is a fundamental operation in IP routing where, given an IP address,
you need to find the most specific (longest) matching prefix in a routing
table. For example, if a table contains both 192.168.0.0/16 and
192.168.1.0/24, a lookup for 192.168.1.1 would return the /24 route.
.SS Features
.IX Subsection "Features"
.IP \(bu 4
\&\fBHigh Performance\fR: Direct XS bindings to optimized C library
.IP \(bu 4
\&\fBDual Stack\fR: Full support for both IPv4 and IPv6
.IP \(bu 4
\&\fBMultiple Algorithms\fR: DIR\-24\-8 for IPv4, Wide 16\-bit stride for IPv6
.IP \(bu 4
\&\fBBatch Operations\fR: Efficient batch lookups to reduce overhead
.IP \(bu 4
\&\fBSIMD Optimized\fR: Runtime CPU feature detection for optimal performance
.IP \(bu 4
\&\fBMemory Safe\fR: Automatic cleanup via Perl's reference counting
.SH "CONSTRUCTOR METHODS"
.IX Header "CONSTRUCTOR METHODS"
.SS new_ipv4
.IX Subsection "new_ipv4"
.Vb 1
\&    my $table = Net::LPM\->new_ipv4();
.Ve
.PP
Creates a new IPv4 routing table using the DIR\-24\-8 algorithm.
This provides optimal lookup performance with typically 1\-2 memory
accesses per lookup.
.PP
Returns a new Net::LPM object.
.PP
Dies on failure (e.g., out of memory).
.SS new_ipv6
.IX Subsection "new_ipv6"
.Vb 1
\&    my $table = Net::LPM\->new_ipv6();
.Ve
.PP
Creates a new IPv6 routing table using the Wide 16\-bit stride algorithm.
This is optimized for common /48 prefix allocations.
.PP
Returns a new Net::LPM object.
.PP
Dies on failure.
.SH "INSTANCE METHODS"
.IX Header "INSTANCE METHODS"
.SS insert
.IX Subsection "insert"
.Vb 3
\&    $table\->insert($prefix, $next_hop);
\&    $table\->insert("192.168.0.0/16", 100);
\&    $table\->insert("2001:db8::/32", 200);
.Ve
.PP
Inserts a route into the table.
.PP
\&\fBParameters:\fR
.IP \(bu 4
\&\f(CW$prefix\fR \- CIDR notation prefix (e.g., "192.168.0.0/16" or "2001:db8::/32")
.IP \(bu 4
\&\f(CW$next_hop\fR \- Unsigned 32\-bit integer representing the next hop
.PP
Returns true on success.
.PP
Dies on error (invalid prefix format, prefix length out of range, etc.).
.SS delete
.IX Subsection "delete"
.Vb 2
\&    my $deleted = $table\->delete($prefix);
\&    $table\->delete("192.168.0.0/16");
.Ve
.PP
Deletes a route from the table.
.PP
\&\fBParameters:\fR
.IP \(bu 4
\&\f(CW$prefix\fR \- CIDR notation prefix to delete
.PP
Returns true if the prefix was found and deleted, false if not found.
.PP
Dies on error (invalid prefix format).
.SS lookup
.IX Subsection "lookup"
.Vb 3
\&    my $next_hop = $table\->lookup($address);
\&    my $nh = $table\->lookup("192.168.1.1");
\&    my $nh = $table\->lookup("2001:db8::1");
.Ve
.PP
Looks up a single IP address in the table.
.PP
\&\fBParameters:\fR
.IP \(bu 4
\&\f(CW$address\fR \- IP address to lookup (dotted-quad for IPv4, colon notation for IPv6)
.PP
Returns the next hop value if a matching prefix is found, \f(CW\*(C`undef\*(C'\fR otherwise.
.PP
Dies on error (invalid address format, wrong IP version).
.SS lookup_batch
.IX Subsection "lookup_batch"
.Vb 2
\&    my @next_hops = $table\->lookup_batch(\e@addresses);
\&    my @results = $table\->lookup_batch([qw(192.168.1.1 10.0.0.1 172.16.0.1)]);
.Ve
.PP
Performs batch lookup for multiple addresses. This is more efficient than
calling \fBlookup()\fR multiple times because it amortizes the Perl/C call overhead.
.PP
\&\fBParameters:\fR
.IP \(bu 4
\&\f(CW\*(C`\e@addresses\*(C'\fR \- Array reference of IP addresses to lookup
.PP
Returns a list of next hop values (or \f(CW\*(C`undef\*(C'\fR for addresses with no match),
in the same order as the input addresses.
.PP
Dies on error (invalid address, wrong IP version).
.SS is_ipv4
.IX Subsection "is_ipv4"
.Vb 1
\&    if ($table\->is_ipv4) { ... }
.Ve
.PP
Returns true if this is an IPv4 table.
.SS is_ipv6
.IX Subsection "is_ipv6"
.Vb 1
\&    if ($table\->is_ipv6) { ... }
.Ve
.PP
Returns true if this is an IPv6 table.
.SS print_stats
.IX Subsection "print_stats"
.Vb 1
\&    $table\->print_stats();
.Ve
.PP
Prints internal statistics about the routing table to STDOUT.
Useful for debugging and performance analysis.
.SH "CLASS METHODS"
.IX Header "CLASS METHODS"
.SS version
.IX Subsection "version"
.Vb 1
\&    my $version = Net::LPM\->version();
.Ve
.PP
Returns the version string of the underlying liblpm C library.
.SH DESTRUCTOR
.IX Header "DESTRUCTOR"
The destructor is automatically called when the object goes out of scope
or is explicitly undefined. It frees all C resources associated with
the routing table.
.PP
.Vb 2
\&    undef $table;  # Explicitly destroy
\&    # Or just let it go out of scope
.Ve
.SH EXPORTS
.IX Header "EXPORTS"
The following constants can be exported:
.PP
.Vb 3
\&    use Net::LPM qw(LPM_INVALID_NEXT_HOP);
\&    use Net::LPM qw(:constants);
\&    use Net::LPM qw(:all);
.Ve
.SS LPM_INVALID_NEXT_HOP
.IX Subsection "LPM_INVALID_NEXT_HOP"
The value returned internally when no matching prefix is found.
In the Perl API, this is converted to \f(CW\*(C`undef\*(C'\fR, but the constant
is available if needed for comparison.
.SH PERFORMANCE
.IX Header "PERFORMANCE"
.SS "XS Overhead"
.IX Subsection "XS Overhead"
While the C library provides nanosecond-scale lookups, the XS binding
adds some overhead (~5\-20ns per call). For high-performance applications:
.IP \(bu 4
Use \f(CWlookup_batch()\fR instead of multiple \f(CWlookup()\fR calls
.IP \(bu 4
Reuse table objects (avoid create/destroy cycles)
.IP \(bu 4
Keep tables in scope during lookup-intensive operations
.SS "Batch Operations"
.IX Subsection "Batch Operations"
Batch operations amortize the Perl/XS overhead across multiple lookups:
.PP
.Vb 2
\&    # Slower: N XS calls
\&    my @results = map { $table\->lookup($_) } @addresses;
\&    
\&    # Faster: 1 XS call
\&    my @results = $table\->lookup_batch(\e@addresses);
.Ve
.SH "THREAD SAFETY"
.IX Header "THREAD SAFETY"
\&\fBNet::LPM objects are NOT thread-safe.\fR
.PP
Each table should only be accessed from a single thread. For multi-threaded
applications, either:
.IP \(bu 4
Use separate tables per thread
.IP \(bu 4
Add external synchronization (e.g., using threads::shared)
.PP
Read-only lookups can be done concurrently if no modifications occur.
.SH "MEMORY MANAGEMENT"
.IX Header "MEMORY MANAGEMENT"
The module uses Perl's reference counting for automatic memory management.
When a Net::LPM object goes out of scope or is undefined, the underlying
C resources are automatically freed.
.PP
For explicit control:
.PP
.Vb 1
\&    undef $table;  # Immediately free resources
.Ve
.SH "ERROR HANDLING"
.IX Header "ERROR HANDLING"
Methods die on error with descriptive messages. Use eval or Try::Tiny
for error handling:
.PP
.Vb 1
\&    use Try::Tiny;
\&    
\&    try {
\&        $table\->insert("invalid\-prefix", 100);
\&    } catch {
\&        warn "Insert failed: $_";
\&    };
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP \(bu 4
<https://github.com/MuriloChianfa/liblpm> \- liblpm project
.IP \(bu 4
Net::IP \- Pure Perl IP address manipulation
.IP \(bu 4
NetAddr::IP \- IP address manipulation with prefix support
.SH AUTHOR
.IX Header "AUTHOR"
Murilo Chianfa <murilo.chianfa@outlook.com>
.SH LICENSE
.IX Header "LICENSE"
This library is licensed under the Boost Software License 1.0.
.SH COPYRIGHT
.IX Header "COPYRIGHT"
Copyright (c) Murilo Chianfa. All rights reserved.
