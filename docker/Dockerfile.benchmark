# DPDK benchmark container for liblpm
# Comparison benchmarking: liblpm vs DPDK LPM
# May require --privileged for hugepages

FROM ubuntu:25.10

LABEL maintainer="Murilo Chianfa <murilo.chianfa@outlook.com>"
LABEL description="liblpm DPDK benchmark environment for performance comparison"

ENV DEBIAN_FRONTEND=noninteractive

# Install build dependencies
RUN apt-get update && apt-get install -y --no-install-recommends \
    ca-certificates \
    # Build tools
    build-essential \
    gcc-15 \
    g++-15 \
    cmake \
    ninja-build \
    make \
    git \
    pkg-config \
    # DPDK dependencies
    python3 \
    python3-pip \
    python3-pyelftools \
    libnuma-dev \
    meson \
    ninja-build \
    # Download tools
    wget \
    curl \
    tar \
    # Utilities
    pciutils \
    && rm -rf /var/lib/apt/lists/*

# Set compiler
RUN update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-15 100 && \
    update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-15 100

# ============================================================================
# Install DPDK 24.11 (cached layer - won't rebuild on liblpm code changes)
# ============================================================================
ENV DPDK_VERSION=24.11
ENV DPDK_DIR=/opt/dpdk

RUN mkdir -p /tmp/dpdk-build && cd /tmp/dpdk-build && \
    wget -q https://fast.dpdk.org/rel/dpdk-${DPDK_VERSION}.tar.xz && \
    tar xf dpdk-${DPDK_VERSION}.tar.xz && \
    cd dpdk-${DPDK_VERSION} && \
    meson setup build \
        --prefix=${DPDK_DIR} \
        -Dexamples="" \
        -Dtests=false \
        -Ddisable_drivers="*" \
        -Denable_drivers="" \
        -Dplatform=generic \
        -Dbuildtype=release \
        -Dc_args="-O3" \
        -Denable_kmods=false && \
    ninja -C build && \
    ninja -C build install && \
    ldconfig && \
    cd / && rm -rf /tmp/dpdk-build

# Set PKG_CONFIG_PATH and library path for DPDK
ENV PKG_CONFIG_PATH="${DPDK_DIR}/lib/x86_64-linux-gnu/pkgconfig"
ENV LD_LIBRARY_PATH="${DPDK_DIR}/lib/x86_64-linux-gnu"

# Add DPDK library path to ldconfig
RUN echo "${DPDK_DIR}/lib/x86_64-linux-gnu" > /etc/ld.so.conf.d/dpdk.conf && ldconfig

# ============================================================================
# Clone and build external LPM libraries for benchmarking
# ============================================================================
ENV EXTERNAL_LPM_DIR=/opt/external

# 1. rmind/liblpm - Simple LPM library (C)
# Build with renamed symbols to avoid conflicts with our liblpm
RUN git clone --depth 1 https://github.com/rmind/liblpm.git ${EXTERNAL_LPM_DIR}/rmindlpm && \
    cd ${EXTERNAL_LPM_DIR}/rmindlpm/src && \
    # Compile with -fvisibility=hidden and use objcopy to rename symbols
    gcc -O3 -fPIC -c lpm.c -o lpm.o && \
    # Create symbol rename map
    echo 'lpm_create rmind_lpm_create' > symbol_rename.txt && \
    echo 'lpm_destroy rmind_lpm_destroy' >> symbol_rename.txt && \
    echo 'lpm_clear rmind_lpm_clear' >> symbol_rename.txt && \
    echo 'lpm_insert rmind_lpm_insert' >> symbol_rename.txt && \
    echo 'lpm_remove rmind_lpm_remove' >> symbol_rename.txt && \
    echo 'lpm_lookup rmind_lpm_lookup' >> symbol_rename.txt && \
    echo 'lpm_lookup_prefix rmind_lpm_lookup_prefix' >> symbol_rename.txt && \
    echo 'lpm_strtobin rmind_lpm_strtobin' >> symbol_rename.txt && \
    # Rename symbols using objcopy
    objcopy --redefine-syms=symbol_rename.txt lpm.o lpm_renamed.o && \
    ar rcs librmindlpm.a lpm_renamed.o && \
    cp librmindlpm.a ${EXTERNAL_LPM_DIR}/ && \
    # Create a header with the renamed function declarations
    echo '#ifndef RMIND_LPM_H' > ${EXTERNAL_LPM_DIR}/rmind_lpm.h && \
    echo '#define RMIND_LPM_H' >> ${EXTERNAL_LPM_DIR}/rmind_lpm.h && \
    echo '#include <stddef.h>' >> ${EXTERNAL_LPM_DIR}/rmind_lpm.h && \
    echo 'typedef struct lpm rmind_lpm_t;' >> ${EXTERNAL_LPM_DIR}/rmind_lpm.h && \
    echo 'rmind_lpm_t *rmind_lpm_create(void);' >> ${EXTERNAL_LPM_DIR}/rmind_lpm.h && \
    echo 'void rmind_lpm_destroy(rmind_lpm_t *);' >> ${EXTERNAL_LPM_DIR}/rmind_lpm.h && \
    echo 'void rmind_lpm_clear(rmind_lpm_t *, void (*)(void *, const void *, size_t, void *), void *);' >> ${EXTERNAL_LPM_DIR}/rmind_lpm.h && \
    echo 'int rmind_lpm_insert(rmind_lpm_t *, const void *, size_t, unsigned, void *);' >> ${EXTERNAL_LPM_DIR}/rmind_lpm.h && \
    echo 'int rmind_lpm_remove(rmind_lpm_t *, const void *, size_t, unsigned);' >> ${EXTERNAL_LPM_DIR}/rmind_lpm.h && \
    echo 'void *rmind_lpm_lookup(rmind_lpm_t *, const void *, size_t);' >> ${EXTERNAL_LPM_DIR}/rmind_lpm.h && \
    echo 'int rmind_lpm_lookup_prefix(rmind_lpm_t *, const void *, size_t, void **);' >> ${EXTERNAL_LPM_DIR}/rmind_lpm.h && \
    echo 'int rmind_lpm_strtobin(const char *, void *, size_t *, unsigned *);' >> ${EXTERNAL_LPM_DIR}/rmind_lpm.h && \
    echo '#endif' >> ${EXTERNAL_LPM_DIR}/rmind_lpm.h && \
    echo "rmind/liblpm built successfully with renamed symbols"

# 2. libpatricia (brandt/network-patricia) - C implementation
RUN git clone --depth 1 https://github.com/brandt/network-patricia.git ${EXTERNAL_LPM_DIR}/libpatricia && \
    cd ${EXTERNAL_LPM_DIR}/libpatricia && \
    gcc -O3 -fPIC -c patricia.c -o patricia.o && \
    ar rcs libpatricia.a patricia.o && \
    cp libpatricia.a ${EXTERNAL_LPM_DIR}/ && \
    cp patricia.h ${EXTERNAL_LPM_DIR}/ && \
    echo "libpatricia built successfully"

# Note: SAIL and XorOffsetTrie are C++ libraries and are skipped.

# Create include directory with all headers
RUN mkdir -p ${EXTERNAL_LPM_DIR}/include && \
    cp ${EXTERNAL_LPM_DIR}/*.h ${EXTERNAL_LPM_DIR}/include/ 2>/dev/null || true && \
    ls -la ${EXTERNAL_LPM_DIR}/ && \
    echo "External LPM libraries ready"

# ============================================================================
# Copy and build liblpm (rebuilds on code changes)
# ============================================================================
WORKDIR /build

# Copy source code
COPY . /build/liblpm/

# Initialize submodules
RUN cd /build/liblpm && \
    git config --global --add safe.directory /build/liblpm && \
    if [ -f .gitmodules ]; then git submodule update --init --recursive; fi

# Build liblpm without DPDK first (with external LPM benchmarks)
RUN cd /build/liblpm && \
    mkdir -p build && cd build && \
    cmake \
        -DCMAKE_BUILD_TYPE=Release \
        -DBUILD_TESTS=OFF \
        -DBUILD_BENCHMARKS=ON \
        -DWITH_DPDK_BENCHMARK=OFF \
        -DWITH_EXTERNAL_LPM_BENCHMARK=ON \
        -DEXTERNAL_LPM_DIR=${EXTERNAL_LPM_DIR} \
        -DENABLE_NATIVE_ARCH=OFF \
        -GNinja \
        .. && \
    ninja

# Build liblpm with DPDK benchmark (with external LPM benchmarks)
RUN cd /build/liblpm && \
    mkdir -p build_dpdk && cd build_dpdk && \
    cmake \
        -DCMAKE_BUILD_TYPE=Release \
        -DBUILD_TESTS=OFF \
        -DBUILD_BENCHMARKS=ON \
        -DWITH_DPDK_BENCHMARK=ON \
        -DWITH_EXTERNAL_LPM_BENCHMARK=ON \
        -DEXTERNAL_LPM_DIR=${EXTERNAL_LPM_DIR} \
        -DENABLE_NATIVE_ARCH=OFF \
        -GNinja \
        .. && \
    ninja || echo "DPDK benchmark build attempted (may fail if comparison benchmark not yet implemented)"

# Benchmark runner script
RUN echo '#!/bin/bash\n\
\n\
# Exit on error, but handle DPDK benchmark failures gracefully\n\
set -e\n\
\n\
echo "=== liblpm DPDK Benchmark Comparison ==="\n\
echo "DPDK Version: $DPDK_VERSION"\n\
echo "DPDK Install: $DPDK_DIR"\n\
echo ""\n\
\n\
# Show DPDK configuration\n\
echo "=== DPDK Configuration ==="\n\
pkg-config --modversion libdpdk 2>/dev/null || echo "DPDK pkg-config not found"\n\
pkg-config --libs libdpdk 2>/dev/null || echo "DPDK libs not configured"\n\
echo ""\n\
\n\
# Run liblpm benchmarks\n\
echo "=== Running liblpm Benchmarks ==="\n\
cd /build/liblpm/build/benchmarks\n\
\n\
if [ -f ./bench_lookup ]; then\n\
    echo "Running lookup benchmark..."\n\
    ./bench_lookup\n\
fi\n\
\n\
echo ""\n\
\n\
# Run DPDK comparison if available\n\
# Note: DPDK may fail in containerized environments due to limited kernel access\n\
if [ -f /build/liblpm/build_dpdk/benchmarks/bench_comparison ]; then\n\
    echo "=== Running DPDK Comparison Benchmark ==="\n\
    # Run in a subshell and capture exit code\n\
    set +e\n\
    /build/liblpm/build_dpdk/benchmarks/bench_comparison\n\
    DPDK_EXIT=$?\n\
    set -e\n\
    \n\
    if [ $DPDK_EXIT -ne 0 ]; then\n\
        echo ""\n\
        echo "Warning: DPDK comparison benchmark exited with code $DPDK_EXIT"\n\
        if [ $DPDK_EXIT -eq 139 ]; then\n\
            echo "This is a segmentation fault, likely due to DPDK EAL initialization"\n\
            echo "failing in this containerized environment."\n\
            echo ""\n\
            echo "DPDK requires specific kernel access that may not be available in CI."\n\
            echo "The liblpm benchmarks above completed successfully."\n\
            echo "For full DPDK comparison, run on a host with hugepage support."\n\
        fi\n\
        echo ""\n\
    fi\n\
else\n\
    echo "DPDK comparison benchmark not available"\n\
    echo "This is expected if the DPDK comparison benchmark is not yet implemented"\n\
fi\n\
\n\
echo ""\n\
echo "=== Benchmark Summary ==="\n\
echo "liblpm benchmarks completed successfully!"\n\
' > /build/run_benchmarks.sh && chmod +x /build/run_benchmarks.sh

# Volume for benchmark results
VOLUME ["/build/results"]

# Default command runs benchmarks
CMD ["/build/run_benchmarks.sh"]

# Usage:
# Build: docker build -f docker/Dockerfile.benchmark -t liblpm-benchmark .
# Run: docker run --rm liblpm-benchmark
# Run with hugepages: docker run --rm --privileged liblpm-benchmark
# Save results: docker run --rm -v "$PWD/results:/build/results" liblpm-benchmark
